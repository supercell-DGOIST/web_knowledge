**自我介绍：**
我叫唐晓铧，今年28岁，毕业于商丘师范学院。16年7月至17年7月我就职于**深圳微创网络科技发展有限公司**从事前端开发的工作，主要负责《代理商管理系统》和《礼品商城》的商品列表及详情，商品管理等模块开发及维护工作。17年7月至19年6月在**软通动力信息技术有限公司**，在华为cloudbu主要负责《微服务引擎》和《微服务云应用平台》的引擎列表，仪表盘，创建微服务，服务治理等模块的开发及维护工作。19年7月至20年1月在**拓保软件有限公司**，在平安银行的软件开发部主要负责《平安金融保险服务合同流程管理系统》和《语音模板管理系统》的技术选型、项目搭建、业务模块开发及维护工作。20年3月至20年12月在**上海现代友商软件有限公司**，在腾云天下的软件开发部门主要负责《广告监测平台》、《后台系统》、《CDP-AM》、《画像报表》、《cm-系统》、《红网标签系统》等项目的模块开发及维护工作，其中负责《cm-系统》和《红网标签系统》的项目搭建。21年1月至21年4月在**软通动力信息技术有限公司**，在华为松山湖基地的公共开发部主要负责《ODAE设计器》项目中的公共定义，主题域，主题，数据标准等模块的开发及维护工作。后因生病离职期间做些兼职体检没问题后重新开始找工作。

面试题：

 **1、js数据类型**：

**基础数据类型**：String, Number, Boolean, undefined, Null ,  Symbol;

**引用数据类型**: Array, Object, Set, Map, Date, RegExp;

**2、面对对象的基本原则和特性**：

**三大特性：**

> **封装：** 隐藏对象的属性和实现细节，仅对外公开接口，控制程序中的读取和修改的访问级别，将抽象得到的数据和行为相结合形成一个类。封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，以特定的访问权限来使用类。
> 
> **继承：** 继承允许创建分等级层次的类。继承就是子类继承父类的特征和行为，使子类对象具有父类的属性和方法。继承可以提高代码复用率。
> 
> **多态：** 多态就是同一个行为具有多个不同表现形式，优点是：可替换性，消除类型之间的耦合关系，可扩充性，接口性，灵活性，简化性。

**五大原则：**

> **单一职责（SRP）：** 一个类应该只有一个发生变化的原因，应该只有一个职责。
> 
> **开放封闭（COP）：** 对象或实体应该对扩展开放，对修改封闭。
> 
> **里氏替换（LSP）：** 子类可以扩展父类的功能，但是不能改变父类原有的功能。
> 
> **依赖倒置（DIP）：** 程序要依赖于抽象接口，不要依赖于具体实现。高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。
> 
> **接口隔离（ISP）：** 用多个专门的接口，而不是使用单一的总接口。 

**3、原型和原型链：**

每个实例对象（object）都有一个私有属性（称之为 __proto__）指向它的构造函数的原型对象（**prototype**），该原型对象也有一个自己的原型对象（__proto__），然后层层往上直到null，就形成了原型链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。

**4、闭包：**

js有一种函数作用域，闭包就是利用函数作用域，在函数内嵌套函数，内部作用域访问外部作用域就形成了闭包，闭包如果频繁使用的话会导致内存泄漏，原因是js的执行环境执行完之后会被释放，但是由于内部作用域使用了外部作用域的变量导致外部作用域需要等到内部作用域使用完了之后才能被释放，所以频繁使用的话就会导致内存泄漏。

**5、作用域：**

**作用域**是当前的执行上下文，[值](https://developer.mozilla.org/zh-CN/docs/Glossary/Value)和表达式在其中“可见”或可被访问。目前分为：全局作用域、模块作用域、函数作用域、块级作用域。

**6、 深浅拷贝的区别：**

js中有两种数据类型，基础数据类型和引用数据类型，基础数据类型变量和引用数据类型的指针存放在栈内存中，引用数据类型的主体存放在堆内存中，栈里面存放的引用数据类型的指针会指向对应的堆内存中主体，浅拷贝是只拷贝了栈内存中的基础数据类型的变量和引用数据类型的指针，没有拷贝到引用数据类型的主体，所以新的指针还是指向原来的主体，如果使用新的指针进行修改会影响到原来的主体，深拷贝在拷贝栈内存中的基础数据类型变量和引用类型数据的指针的同时也会拷贝一份堆内存中的引用数据类型的主体并指向新的指针，也就不存在会修改原来的主体的问题。

**浅拷贝的方法：** 赋值，各种循环方法，扩展运算符， Array: slice, flat，flatMap，map, reduce，concat, from, Object: assign

**深拷贝：** JSON.parse(JSON.stringify()), 类型判断，循环，递归

**7、json.stringify实现原理，和缺点:**

将js对象或值序列化成一个 JSON 字符串，然后解析这个字符串成一个对象。

**缺点：**

> 1、`function`，`undefined`，`Symbol`，这三种数据类型会被忽略。
> 
> 2、NaN，Infinity，会变成null。
> 
> 3、Date对象会被调用toJSON，转换成字符串。
> 
> 4、RegExp，Map，Set，Error，都会变成空对象。
> 
> 5、无法序列化循环引用的对象。

**8、cookie和localStorage以及sessionStorage的区别**

> **cookie**：一般由服务器生成，可以设置失效时间；若没有设置时间，关闭浏览器页面cookie失效，如果设置了时间，cookie就会存储在本地，过期失效。主要用于用户识别和状态管理，存储大小在4KB左右，cookie在浏览器和服务器之间来回传递，如果使用cookie保存过多数据会造成性能问题。
> 
> **sessionStorage：** 仅保存在当前会话中，关闭页面或浏览器后被清除，单页面应用较多，存储大小在5MB左右，保存在客户端，不参与服务器通信。
> 
> **localStorage：** 长期保存在本地，适用于长期保存本地数据，存储大小在5MB左右，保存在客户端，不参与服务器通信。 

**9、常见的状态码：**

**100：** 继续，客户端继续请求。

**200**：请求成功。

**204**：服务器成功处理了请求，但不需要返回任何实体内容。

**206**：服务器已经成功处理了部分 GET 请求

**301**：永久移动，被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。

**302**：临时移动，请求的资源临时从不同的 URI响应请求。

**303**：服务器指示客户端请求另一个url的资源。

**304**：缓存版本没有被修改。

**307**：临时重定向。

**400**：语义或参数错误，服务器无法处理请求。

**401**：请求要求用户身份认证。

**403**：服务器拒绝该请求。

**404**：服务器找不到请求资源。

**408**：请求超时。

**500**：服务器内部错误。

**502**：网关错误。

**503**：服务不可用，可能因维护或重载而停机。

**504**：网关超时。

**10、主流浏览器内核：**

**IE/Edge：** Trident.

**FireFox：** Gecko.

**Safari：** Webkit.

**chrome：** Blink.

**Opera：** Blink.

**11、强缓存，协商缓存**

**强缓存：** 

**expires：** 设置在响应头包含日期或时间，从本地获取时间戳来判断是否需要对服务器发起请求，不需要发起请求直接从本地缓存中读取，本地时间有可能和服务器时间对不上。

**cache-control(优先级更高)：** 设置缓存时间，在缓存时间内直接从本地缓存中读取，过了时间才会去请求服务器。

**协商缓存：**

需要设置cache-control=no-cache

**Last-Modified，If-Modified-Since**：对比资源最后一次的修改时间。

**Etag，If-None-Match**：对比资源的特定标识符(哈希码)，分为强验证和弱验证，强验证是Etag生成的哈希码深入每个字节，确保文件的绝对不变，弱验证是提取文件的部分属性来生成哈希值，准确率不高了，缺点比较消耗计算性能。

`协商缓存`是要走服务端的，如果请求某个资源，去请求服务端时，发现`命中缓存`则返回`304`，否则则返回所请求的资源。

**优点：** 减少不必要的网络传输，节约带宽，更快的加载页面，减少服务器负载，避免服务器过载的情况出现。

**使用场景：**

有哈希值的文件设置强缓存，没有哈希值的文件设置协商缓存（如index.html）。

**12、节流、防抖**

**防抖：** 设置事件需要触发的时间，在时间内再次触发事件重新计时，过了需要触发的时间才可以触发事件，适用于搜索，浏览器窗口大小等事件。

**节流：** 设置事件在一段时间后会触发一次，如果在时间内连续触发多次，只有第一次的会生效，适用于鼠标点击和滚动事件。

**13、apply、call的区别**

**apply：** 参数thisArg是方法运行时的this值，argsArray是数组或类数组对象。（数组取最大或最小值）

**call：**  参数thisArg是方法运行时的this值，arg是参数列表。（继承方法，获取值类型）

**bind：** 绑定函数this值，返回原函数的拷贝。

**14、Promise**

Promise的原理就是观察者模式，步骤顺序是**收集》通知》执行**，收集指的是从then方法中收集fulfilled和rejected的回调函数储存在事件队列中等待通知，通知是指异步完成后，通过resolve或reject接收响应内容，接受成功后根据接收情况然后改变promise实例的状态并缓存响应内容后取出存储事件队列里的回调函数并执行。

**15、Generator函数原理**

Generator函数就是一个异步任务的容器，当它内部执行到yield关键字时会暂停把执行权交给其他协程，等执行权返回后再继续往下执行，Generator函数会返回一个遍历器，调用next方法后会返回一个对象表示当前阶段的信息(value和done)，value属性是yield语句后面表达式的值，done属性是指Generator函数是否执行完成。

**16、Async/await**

Async函数是 Generator 函数的语法糖，它自带执行器，有着更好的语义和更广的适用性，内部执行时遇到await就会等待异步操作完成，然后再执行后面的内容，它的返回值是个promise对象，任何一个`await`语句后面的 Promise 对象变为`reject`状态，那么整个`async`函数都会中断执行，所以需要放在try...catch里面。

**17、ES6新特性**

 **let：** 声明变量，块级作用域，不存在变量提升，不允许重复声明。

 **const：** 声明常量，块级作用域，不存在变量提升，不允许重复声明，不能改变值。

**解构赋值：** 字符串：const [a, b, c] = 'abc'；对象：const {x} = {x: 1};  数组: const [x] = [1]；函数：function([a, b, c]) {}

**字符串的扩展：** 

> **字符串遍历**：可通过`for-of`遍历字符串
> 
> **字符串模板**：可单行可多行可插入变量的增强版字符串 ‘string  a  ${name}’
> 
> **标签模板**：可单行可多行可插入变量的增强版字符串  tag‘string ${num}’ === tag(['string'], num)
> 
> **标签模板**：可单行可多行可插入变量的增强版字符串 tag‘string ${num}’ === tag(['string'], num)
> 
> **repeat()：** 把字符串重复n次，返回`新字符串`
> 
> **includes()：** 是否存在指定字符串
> 
> **startsWith()：** 原字符串的头部是否存在指定字符串
> 
> **endsWith()：** 原字符串的尾 部是否存在指定字符串
> 
> **trimStart()：** 消除字符串头部空格，返回新字符串
> 
> **trimEnd()：** 消除字符串尾部空格，返回新字符串
> 
> **matchAll()：** 返回正则表达式在字符串的所有匹配

**对象的扩展：**

> **属性的遍历：**
> 
> + **for...in：** 循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。
> + **Object.keys(obj)：** 返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。
> + **Object.getOwnPropertyNames(obj)：** 返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。
> + **Object.getOwnPropertySymbols(obj)：** 返回一个数组，包含对象自身的所有 Symbol 属性的键名。
> + **Reflect.ownKeys(obj)：** 返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。

> **super关键字：** 指向当前对象的原型对象
> 
> **Object.is()**：对比两值是否相等
> 
> **Object.assign()**：合并对象(浅拷贝)，返回原对象
> 
> **Object.getPrototypeOf()**：返回对象的原型对象
> 
> **Object.setPrototypeOf()**：设置对象的原型对象
> 
> **Object.values()**：返回以值组成的数组
> 
> **Object.entries()**：返回以键和值组成的数组
> 
> **Object.fromEntries()**：将一个键值对数组转为对象
> 
> **Object.hasOwn()**：判断指定的对象自身是否有指定的属性

**数组的扩展：**

> **Array.from():** 将类数组或可迭代对象转换成一个新数组。
> 
> **Array.of():** 将一组值，转换为数组。
> 
> **Array.find():** 返回第一个符合条件的成员。
> 
> **Array.findIndex():** 返回第一个符合条件的成员索引值
> 
> **Array.findLast():** 返回从后往前检查第一个符合条件的成员
> 
> **Array.findLastIndex():** 返回从后往前检查第一个符合条件的成员索引值
> 
> **Array.fill():** 使用给定值，填充一个数组
> 
> **Array.keys():** 返回以索引值为遍历器的对象
> 
> **Array.values():** 返回以属性值为遍历器的对象
> 
> **Array.entries():** 返回以索引值和属性值为遍历器的对象
> 
> **Array.includes():** 是否存在指定成员
> 
> **Array.flat():** 扁平化数组，返回新数组
> 
> **Array.flatMap():** 映射且扁平化数组，返回新数组(只能展开一层数组)
> 
> **Array.at():** 通过索引取值

**函数的扩展：**

> **参数默认值：** 为函数参数指定默认值
> 
> **rest 参数：** 获取函数的多余参数
> 
> **name属性**：返回函数的函数名
> 
> **箭头函数(=>)**：函数简写，无自身this
> 
> **尾调用优化**：只保留内层函数的调用帧

**Symbol：** 表示独一无二的值

**Set：** 类似于数组，但是成员的值都是唯一的，没有重复的值。

> - 属性
>   - **constructor**：构造函数，返回Set
>   - **size**：返回实例成员总数
> - 方法
>   - **add()**：添加值，返回实例
>   - **delete()**：删除值，返回布尔
>   - **has()**：检查值，返回布尔
>   - **clear()**：清除所有成员
>   - **keys()**：返回以属性值为遍历器的对象
>   - **values()**：返回以属性值为遍历器的对象
>   - **entries()**：返回以属性值和属性值为遍历器的对象
>   - **forEach()**：使用回调函数遍历每个成员

**WeakSet：** 成员值只能是对象。

> - 属性
>   - **constructor**：构造函数，返回WeakSet
> - 方法
>   - **add()**：添加值，返回实例
>   - **delete()**：删除值，返回布尔
>   - **has()**：检查值，返回布尔

**Map：** 类似于对象的数据结构，成员键是任何类型的值

> - 属性
>   - **constructor**：构造函数，返回Map
>   - **size**：返回实例成员总数
> - 方法
>   - **get()**：返回键值对
>   - **set()**：添加键值对，返回实例
>   - **delete()**：删除键值对，返回布尔
>   - **has()**：检查键值对，返回布尔
>   - **clear()**：清除所有成员
>   - **keys()**：返回以键为遍历器的对象
>   - **values()**：返回以值为遍历器的对象
>   - **entries()**：返回以键和值为遍历器的对象
>   - **forEach()**：使用回调函数遍历每个成员

**WeakMap：** 和Map结构类似，成员键只能是对象属性

> - - **constructor**：构造函数，返回WeakMap
> - 方法
>   - **get()**：返回键值对
>   - **set()**：添加键值对，返回实例
>   - **delete()**：删除键值对，返回布尔
>   - **has()**：检查键值对，返回布尔

**Class：** 对一类具有共同特征的事物的抽象(构造函数语法糖)

> - 方法和关键字
>   - **constructor()**：构造函数，`new命令`生成实例时自动调用
>   - **extends**：继承父类
>   - **super**：`super`作为函数调用时，代表父类的构造函数，创建子类的this值，`super`作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。
>   - **static**：定义静态属性方法
>   - **get**：取值函数，拦截属性的取值行为
>   - **set**：存值函数，拦截属性的存值行为
>   - /**#**/：私有属性写法
>   - **static {}**：静态块，如果静态属性有初始化逻辑，可以使用静态块

**Module：**

> **命令：**
> 
> - **export**：规定模块对外接口
> 
> - **import**：导入模块内部功能
> 
> - **import()**：动态导入(返回`Promise`)

**加载实现**

- **传统加载**：通过`<script>`进行同步或异步加载脚本
  - 同步加载：`<script src=""></script>`
  - Defer异步加载：`<script src="" defer></script>`(顺序加载，渲染完再执行)
  - Async异步加载：`<script src="" async></script>`(乱序加载，下载完就执行)
- **模块加载**：`<script type="module" src=""></script>`(默认是Defer异步加载)

**18、h5和css3的新特性**

 **H5新特性：**

> **语义化标签：** header、footer、section、nav、aside、article
> 
> **增强型表单：** input的属性，比如：color、date、email、month、number、range、url、search
> 
> **新增表单元素：** output、datalist
> 
> **新增表单属性：** placehoder、required、pattern、autofocus
> 
> **音频视频：** audio 、video、source
> 
> **canvas：** 
> 
> **地理定位：** navigator.geolocation.getCurrentPosition 获取当前位置，navigator.geolocation.watchPosition 返回用户的当前位置，并继续返回用户移动时的更新位置
> 
> **拖拽：** draggable：设置元素可拖放、ondragstart：拖动开始可以设置参数event.dataTransfer.setData设置传递值，放下的时候需要使用event.preventDefault：禁止事件默认行为，使用ondrop写释放后的逻辑
> 
> **webstorage：** localStorage、sessionStorage
> 
> **新事件：** onresize，ondrag、onscroll、onplay
> 
> **WebSocket：** 即时通信协议

**Css3新特性：**

> **选择器：** 属性选择器和伪元素：E:nth-child(n)、E:disabled、E:checked、E::selection
> 
> **形状转换：** transform
> **动画、过渡：** transition、animation需要配合@keyframes
> 
> **阴影：** box-shadow、text-shadow
> 
> **filter(滤镜)：** 黑白色filter: grayscale
> 
> **布局：** 弹性布局 display: flex、栅格布局display: gried
> 
> **盒模型定义：** 确切定义某个地区的具体内容box-sizing、用户调整元素大小resize、轮廓偏移outline-offset
> 
> **web字体：** @font-face
> 
> **媒体查询：** @media screen and (max-width: 960px) {}

**19、flex**

**容器属性：**

> **display：flex** 开启弹性布局，**inline-flex** 行内元素开启弹性布局
> 
> **flex-direction：** 定义主轴的方向
> 
> **flex-wrap：** 一条轴线排不下，定义如何换行
> 
> **flex-flow：** 同时设置flex-direction和flex-wrap
> 
> **justify-content：** 定义了项目在主轴上的对齐方式。
> 
> **align-items：** 定义了项目在交叉轴上如何对齐。

**项目的属性：**

> **order：** 定义项目的排列顺序。数值越小，排列越靠前，默认为0。
> 
> **flex：** 适应容器中的可用空间，属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。
> 
> **align-self：** 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。

**grid**

**容器属性：**

> **display: grid** 开启栅格布局，**inline-grid**  行内元素开启栅格布局
> 
> **grid-template-columns：** 定义列尺寸
> 
> **grid-gap：** 设置网格行与列之间的间隙
> 
> **grid-template-rows：** 定义行尺寸

**项目的属性：**

> **grid-column-start：** 设置列的开始
> 
> **grid-column-end：** 设置列的结束
> 
> **grid-row-start：** 设置行的开始
> 
> **grid-row-end：** 设置行的结束

**20、事件捕获和事件冒泡**

**事件冒泡：** 事件从内层的元素开始发生，一直向上传播，直到document对象。

> **阻止事件冒泡：** event.stopPropagation()，return false;

**事件捕获：** 事件会从最外层开始发生，直到最具体的元素。

> **阻止默认事件：** event.preventDefault()、return false;

**21、浏览器渲染**

> **GUI 渲染线程：** 
> 
> - 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject 树,布局和绘制等。
> 
> - 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时,该线程就会执行。
> 
> - 注意,GUI 渲染线程与 JS 引擎线程是互斥的,当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了）,GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。
> 
> **JS 引擎线程：** 
> 
> - 负责解析 Javascript 脚本,运行代码。
> 
> **事件触发线程：**
> 
> - 归属于浏览器而不是 JS 引擎,用来控制事件循环，当js引擎执行代码块如setTimeout时，会将对应任务添加到事件线程中。当对应的事件符合触发条件被触发时,该线程会把事件添加到待处理队列的队尾,等待 JS 引擎的处理
> 
> **定时触发器线程：**
> 
> - setInterval 与 setTimeout 所在线程
> 
> **异步 http 请求线程：**
> 
> - 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求，将检测到状态变更时,如果设置有回调函数,异步线程就产生状态变更事件,将这个回调再放入事件队列中。再由 JavaScript 引擎执行。

**22、浏览器渲染流程**

- 解析 HTML 文件,构建 DOM 树,同时浏览器主进程负责下载 CSS 文件

- CSS 文件下载完成,解析 CSS 文件成树形的数据结构,然后结合 DOM 树合并成 RenderObject 树

- 布局 RenderObject 树 （Layout/reflow）,负责 RenderObject 树中的元素的尺寸,位置等计算

- 绘制 RenderObject 树 （paint）,绘制页面的像素信息

- 浏览器主进程将默认的图层和复合图层交给 GPU 进程,GPU 进程再将各个图层合成（composite）,最后显示出页面

**23、回流和重绘**

1. 浏览器使用流式布局模型 (Flow Based Layout)。
2. 回流必将引起重绘，重绘不一定会引起回流。
3. **回流：** ·当`Render Tree`中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。
4. **重绘：** 当页面中元素样式的改变并不影响它在文档流中的位置时（例如：`color`、`background-color`、`visibility`等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。

**24、fetch和axios的区别**

**fetch:**

   `Fetch API` 是基于 `Promise` 设计的支持http请求。

**优点：**

1. 更简洁的代码：相比 `XMLHttpRequest`，`Fetch API` 的语法更加简单易懂，使用起来更加方便。
2. 基于 `Promise` 设计：`Promise` 是 `JavaScript` 中一种非常强大的异步编程机制，可以帮助开发者更好地处理异步操作，避免回调地狱。
3. 支持跨域请求：`Fetch API` 内置了跨域请求的支持，可以让开发者更加轻松地处理跨域问题。
4. 更好的错误处理：`Fetch API` 在网络请求失败时会抛出异常，可以帮助开发者更好地处理错误。
5. 可以自定义请求头：`Fetch API` 允许开发者自定义请求头，可以更好地控制请求。

**缺点：**

1. 不兼容旧版本浏览器：`Fetch API` 并不是所有浏览器都支持的，特别是在一些旧版本浏览器中可能会有兼容性问题。
2. 默认不携带 `cookie`：`Fetch API` 默认不携带 `cookie`，需要手动设置才能携带 `cookie`。
3. 无法取消请求：`Fetch API` 并不支持直接取消请求，需要开发者自己处理取消请求的逻辑。

`Fetch API` 是用于获取和发送资源的现代 `Web API`。它可以使网络请求更加灵活和高效。然而，由于它的开放性和灵活性，`Fetch API` 也可能存在一些安全性问题。以下是一些可能存在的安全性问题：

1. 跨站点请求伪造（`CSRF`）：攻击者可以通过伪造一个可信站点的请求，以在用户不知情的情况下执行某些操作。这可以通过在请求头中包含攻击者的自定义Cookie或其他授权信息来实现。
2. 跨域资源共享（`CORS`）：由于浏览器的同源策略限制，浏览器只允许来自同一域的请求。但是，使用 `CORS`，站点可以通过在响应头中包含 `Access-Control-Allow-Origin` 来授权其他站点进行请求。如果站点的 `CORS` 设置不正确，攻击者可能会利用它来执行跨域攻击。
3. `HTTPS劫持`：攻击者可能会尝试在 `HTTPS` 连接中中间攻击并篡改`Fetch API` 请求。这可以通过使用代理或恶意软件来实现。
4. 注入攻击：如果站点的Fetch API处理不正确，攻击者可能会利用它来执行 `SQL注入` 或其他类型的注入攻击。

为了避免这些安全问题，开发人员应该采取适当的措施来保护站点的`Fetch API`。例如：

1. 使用随机生成的令牌来防止`CSRF`攻击。
2. 设置适当的CORS策略，并使用适当的 `Access-Control-Allow-Origin` 标头来限制请求来源。
3. 在 `HTTPS` 连接中使用证书，并使用证书钩子来验证证书。
4. 对于所有输入，使用参数化查询来避免注入攻击。

**axios:**

优点：

1. `Promise API`：Axios使用`Promise API`，因此可以轻松处理异步操作。`Promise API`具有更清晰的语法和更好的可读性，因为它们允许在异步操作完成之前进行链式调用，从而避免了回调地狱问题。

2. 简单易用：`Axios`的API设计简单且易于使用，而且它还提供了许多可用的配置选项，例如设置请求头、超时时间、认证等等，让开发者可以更轻松地定制请求。

3. 可扩展性：`Axios`可以通过添加拦截器(`interceptors`)来实现许多自定义功能，例如添加请求拦截器、响应拦截器和错误拦截器等等。这些拦截器可以让开发者在请求和响应过程中进行自定义操作。

4. 支持浏览器和`Node.js`：`Axios`可以同时在浏览器和`Node.js`环境中使用。这意味着开发者可以使用相同的代码库在两个不同的环境中实现网络请求功能。

5. 轻量级：`Axios`是一个轻量级库，它只依赖于`Promise`和一些基本的`JavaScript`库，因此它的体积相对较小。

**25.Http/Tcp三次握手和四次挥手**

| 字段  | 含义                                     |
| --- | -------------------------------------- |
| SYN | 请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为 1 |
| ACK | 确认号是否有效，一般置为 1。                        |
| FIN | 释放一个连接。                                |
| PSH | 提示接收端应用程序立即从 TCP 缓冲区把数据读走。             |
| RST | 对方要求重新建立连接，复位。                         |
| URG | 紧急指针（urgent pointer）有效。                |

三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。

**窗口大小** 提供流量控制

![三次握手.png](C:\Users\Administrator\Desktop\面试\三次握手.png)

刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。 进行三次握手：

- 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 `SYN_SEND` 状态。结论：客户端的发送能力、服务端的接收能力是正常的。
  
  首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。

- 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 `SYN_RCVD` 的状态。结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
  
  在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。

- 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 `ESTABLISHED` 状态。服务器收到 ACK 报文之后，也处于 `ESTABLISHED` 状态，此时，双方已建立起了连接。结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。
  
  确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。

**初始序列号** 发送SYN时，会给连接建立一个初始序列号，序列号会随着时间而变化，主要用于客户端和服务端之间接收数据按序列号组装。

**由于安全问题，只有第三次握手才能携带数据**

**四次挥手:**

![四次挥手.png](C:\Users\Administrator\Desktop\面试\四次挥手.png)

TCP 的连接的拆除需要发送四个包，客户端和服务端都可以发送挥手动作。

- 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 `FIN_WAIT1` 状态。
  即发出**连接释放报文段**（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。
- 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 `CLOSE_WAIT` 状态。
  即服务端收到连接释放报文段后即发出**确认报文段**（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。
- 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态。
  即服务端没有要向客户端发出的数据，服务端发出**连接释放报文段**（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。
- 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 `TIME_WAIT` 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 `CLOSED` 状态。
  即客户端收到服务端的连接释放报文段后，对此发出**确认报文段**（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。可能网络是不可靠的，有可能最后一个ACK丢失。所以**TIME_WAIT状态就是用来重发可能丢失的ACK报文**

**26.跨域的方法**

**同源策略** 是指协议、域名、端口都相同，是浏览器基本的安全功能。

**JSONP**

> **JSONP原理：**
> **利用 `<script>` 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。**
> 
> **JSONP优缺点：**
> 
> JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。**缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。**

**CORS（跨源资源共享）**

> CORS需要浏览器和服务端同时支持。服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。
> 
> **简单请求：** 满足两个条件
> 
> 使用方法：
> 
> - GET                               
> - HEAD
> - POST
> 
> Content-Type：
> 
> - text/plain
> - multipart/form-data
> - application/x-www-form-urlencoded
> 
> **复杂请求：** 不符合简单请求的就是复杂请求，在正式通信之前，增加一次HTTP查询请求，称为"预检"请求。

**postMessage** ** 允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递

- 页面和其打开的新窗口的数据传递
- 多窗口之间消息传递
- 页面与嵌套的iframe消息传递
- 上面三个场景的跨域数据传递

**websocket**

Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 **WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据**。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。

**Node中间件代理(两次跨域)**

实现原理：**同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。** 代理服务器，需要做以下几个步骤：

- 接受客户端请求 。
- 将请求 转发给服务器。
- 拿到服务器 响应 数据。
- 将 响应 转发给客户端。

**nginx反向代理**

实现原理类似于Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。

实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。

**window.name + iframe**

name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。

总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。

**location.hash + iframe**

实现原理： a.html欲与c.html跨域相互通信，通过中间页b.html来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。

**document.domain + iframe**

实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。**该方式只能用于二级域名相同的情况下，比如 `a.test.com` 和 `b.test.com` 适用于该方式**。

#### 27.前端性能优化

###### 网络层面

**1.构建策略**

- **减少打包时间**：

- `缩减范围`：配置**include**/**exclude**缩小Loader对文件的搜索范围，使用 **webpack.ignorePlugin** 可以排除不需要的导入的模块，`noParse`过滤无依赖文件

- `缓存副本`：配置babel-loader中的cacheDirectory和其他的缓存，再次编译只编译修改过的文件，cache.type设置filesystem

- `定向搜索`：`alias`映射模块路径，`extensions`表明文件后缀减少可尝试性，`modules`指定解析模块路径

- `提前构建`：配置dllPlugin生成动态链表库，提前把公共代码构建好存在本地，再次构建就再次打包公共代码。

- `并行构建`：配置**thread-loader**的workers属性，**terser-webpack-plugin**、**css-minimizer-webpack-plugin**的parallel属性，**image-minimizer-webpack-plugin** 的concurrency属性，单线程转成多线程

- `可视结构`：配置**bundle-analyzer**插件分析打包文件结构

- **减少打包体积**：

- `分割代码`：  分割各个模块代码，提取出相同部分代码，减少重复代码出现频率，配置**splitChunks**、**runtimeChunk**、**mini-css-extract-plugin** 单独拆出css文件，**externals** 设置三方类库不打包进去，而改用cdn

- `摇树优化`：删除项目中未被使用的代码，只支持ESM规范，只有import/export才能提供静态的**导入/导出**功能。production模式默认开启摇树优化。

- `动态垫片`：`@babel/preset-env`提供的`useBuiltIns`可按需导入`Polyfill`

- `按需加载`：**将路由页面/触发性功能单独打包为一个文件，使用时才加载**，好处是`减轻首屏渲染的负担`。使用内联注释：webpackChunkName、webpackMode、webpackPreload、webpackPrefetch

- `作用域提升`：**分析模块间依赖关系，把打包好的模块合并到一个函数中**，好处是`减少函数声明和内存花销`。在开启`作用提升`后，构建后的代码会按照引入顺序放到一个函数作用域里，通过适当重命名某些变量以防止变量名冲突，从而减少函数声明和内存花销。production模式默认开启。

- `压缩资源`：**html-webpack-plugin** 压缩html，**terser-webpack-plugin** 压缩js，**css-minimizer-webpack-plugin** 压缩css，**image-minimizer-webpack-plugin** 压缩image、**compression-webpack-plugin** 生成gzip文件

**2.图像策略**

- **图像选型**：了解所有图像类型的特点及其何种应用场景最合适
- **图像压缩**：在部署到生产环境前使用工具或脚本对其压缩处理

**3.分发策略**

- **所有静态资源走CDN**：开发阶段确定哪些文件属于静态资源
- **把静态资源与主页面置于不同域名下**：避免请求带上`Cookie`

**4.缓存策略**

减少网络传输损耗

- **考虑拒绝一切缓存策略**：`Cache-Control:no-store`
- **考虑资源是否每次向服务器请求**：`Cache-Control:no-cache`
- **考虑资源是否被代理服务器缓存**：`Cache-Control:public/private`
- **考虑资源过期时间**：`Expires:t/Cache-Control:max-age=t,s-maxage=t`
- **考虑协商缓存**：`Last-Modified/Etag`

![强缓存.png](C:\Users\Administrator\Desktop\面试\强缓存.png)

![协商缓存.png](C:\Users\Administrator\Desktop\面试\协商缓存.png)

`先走强缓存，若命中失败才走协商缓存`。若命中`强缓存`，直接使用`强缓存`；若未命中`强缓存`，发送请求到服务器检查是否命中`协商缓存`；若命中`协商缓存`，服务器返回304通知浏览器使用`本地缓存`，否则返回`最新资源`。

- **频繁变动资源**：设置`Cache-Control:no-cache`，使浏览器每次都发送请求到服务器，配合`Last-Modified/ETag`验证资源是否有效
- **不常变化资源**：设置`Cache-Control:max-age=31536000`，对文件名哈希处理，当代码修改后生成新的文件名，当HTML文件引入文件名发生改变才会下载最新文件

#### 渲染层面

- [x]  **CSS策略**：基于CSS规则
- [x]  **DOM策略**：基于DOM操作
- [x]  **阻塞策略**：基于脚本加载
- [x]  **回流重绘策略**：基于回流重绘
- [x]  **异步更新策略**：基于异步更新

##### CSS策略

- 避免出现超过三层的`嵌套规则`
- 避免为`ID选择器`添加多余选择器
- 避免使用`标签选择器`代替`类选择器`
- 避免使用`通配选择器`，只对目标节点声明规则
- 避免重复匹配重复定义，关注`可继承属性`

##### DOM策略

- 缓存`DOM计算属性`
- 避免过多`DOM操作`
- 使用`DOMFragment`缓存批量化`DOM操作`

##### 阻塞策略

- 脚本与`DOM/其它脚本`的依赖关系很强：对`<script>`设置`defer`
- 脚本与`DOM/其它脚本`的依赖关系不强：对`<script>`设置`async`

##### 回流重绘策略

- 避免使用table布局
- 使用类合并样式，避免逐条改变样式（修改的样式放到一个类名下，通过添加类名形式，使其只执行一次回流重绘过程）
- 使用 `visibility` 替换 `display:none`，前者只会重绘，后者改变布局会引发重排
- 避免使用 CSS 表达式
- CSS3 硬件加速（GPU加速），使用 CSS3 硬件加速，可以让 `transform`、 `opacity`、 `filters` 这些动画不会引起重排重绘。但是对于动画的其它属性，比如 `background-color` 这些，还是会引起重排重绘的，不过它还是可以提升这些动画的性能。
- 使用 `tranform` 替代 `top`，`tranform` 是合成属性，不会引起重排和重绘
- 将动画效果应用到 `position` 属性为 `absolute` 或 `fixed` 的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是重排，同时，控制动画速度可以选择 `requestAnimationFrame`

##### 异步更新策略

- 在`异步任务`中修改`DOM`时把其包装成`微任务`

### 六大指标

- [x]  **加载优化**：资源在加载时可做的性能优化
- [x]  **执行优化**：资源在执行时可做的性能优化
- [x]  **渲染优化**：资源在渲染时可做的性能优化
- [x]  **样式优化**：样式在编码时可做的性能优化
- [x]  **脚本优化**：脚本在编码时可做的性能优化
- [x]  **V8引擎优化**：针对`V8引擎`特征可做的性能优化

##### 加载优化

![加载优化.png](C:\Users\Administrator\Desktop\面试\加载优化.png)

#### DNS预解析具体用法

```bash
//用meta信息来告知浏览器, 当前页面要做DNS预解析
<meta http-equiv="x-dns-prefetch-control" content="on">
在页面header中使用link标签来强制对DNS预解析: 
<link rel="dns-prefetch" href="//www.zhix.net">
```

##### 执行优化

![执行优化.png](C:\Users\Administrator\Desktop\面试\执行优化.png)

##### 渲染优化

![渲染优化.png](C:\Users\Administrator\Desktop\面试\渲染优化.png)

##### 样式优化

![样式优化.png](C:\Users\Administrator\Desktop\面试\样式优化.png)

##### 脚本优化

![脚本优化.png](C:\Users\Administrator\Desktop\面试\脚本优化.png)

##### V8引擎优化

![V8引擎优化.png](C:\Users\Administrator\Desktop\面试\V8引擎优化.png)

#### 28.javascript事件循环

浏览器：

执行栈中同步任务会直接执行，异步任务会被挂起等待完成事件后把回调函数放到任务队列中等待执行（微任务放到微任务队列，宏任务放到宏任务队列），当执行栈为空时，主线程就会去读取微任务队列中的任务执行并清空，然后读取宏任务队列中的任务执行，执行完后查看是否有微任务有的话执行并清空，重复此操作直到所有任务都清空，这个运行机制叫事件循环。

nodejs：

###### 宏任务和微任务

宏任务由运行环境发起，微任务由js发起

宏任务和微任务分别存放在不同的任务队列里面，同一层面微任务优先执行，同一队列的先满足执行条件的先执行，两者是包含关系，script标签也是宏任务。

异步任务分为两类：

**宏任务：** setTimeout、setInterval、requestAnimationFrame、script、postMessage

**微任务：** MutationObserver、Promise.then catch finally

##### RESTFUL特点包括：

**URI**（统一资源标识符）是一个指向资源的字符串。最通常用在 [URL](https://developer.mozilla.org/zh-CN/docs/Glossary/URL) 上来指定 Web 上资源文件的具体位置。

1、每一个URI代表1种资源；

2、客户端使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；

3、通过操作资源的表现形式来操作资源；

4、资源的表现形式是XML或者HTML；

5、客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息

##### BFC 是什么呢

BFC 即 Block Formatting Contexts (块级格式化上下文)，**具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。**

- body 根元素
- 浮动元素：float 除 none 以外的值
- 绝对定位元素：position (absolute、fixed)
- display 为 inline-block、table-cells、flex
- overflow 除了 visible 以外的值 (hidden、auto、scroll)
