[
  {
    "title": "主流浏览器内核",
    "description": "浏览器内核分为渲染引擎和JS引擎。",
    "key": "BrowserKernel",
    "contents": [
      {
        "label": "IE/Edge",
        "contents": [
          {
            "label": "渲染引擎：",
            "text": "Trident"
          },
          {
            "label": "JS引擎：",
            "text": "Chakra"
          }
        ]
      },
      {
        "label": "FireFox",
        "contents": [
          {
            "label": "渲染引擎：",
            "text": "Gecko"
          },
          {
            "label": "JS引擎：",
            "text": "SpiderMonkey"
          }
        ]
      },
      {
        "label": "Safari",
        "contents": [
          {
            "label": "渲染引擎：",
            "text": "Webkit"
          },
          {
            "label": "JS引擎：",
            "text": "JSCores"
          }
        ]
      },
      {
        "label": "Chrome",
        "contents": [
          {
            "label": "渲染引擎：",
            "text": "Blink"
          },
          {
            "label": "JS引擎：",
            "text": "V8"
          }
        ]
      }
    ]
  },
  {
    "title": "进程、线程和协程",
    "description": "",
    "key": "ProcessThreadCollaboration",
    "contents": [
      {
        "label": "进程",
        "contents": [
          {
            "text": "进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。"
          }
        ]
      },
      {
        "label": "线程",
        "contents": [
          {
            "text": "线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。"
          }
        ]
      },
      {
        "label": "协程",
        "contents": [
          {
            "text": "协程，英文Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。"
          }
        ]
      },
      {
        "label": "进程和线程的区别",
        "contents": [
          {
            "label": "调度：",
            "text": "线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。"
          },
          {
            "label": "并发性：",
            "text": "不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行。"
          },
          {
            "label": "拥有资源：",
            "text": "进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。"
          },
          {
            "label": "系统开销：",
            "text": "在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。"
          }
        ]
      },
      {
        "label": "进程和线程的联系",
        "contents": [
          {
            "text": "一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。"
          },
          {
            "text": "资源分配给进程，同一进程的所有线程共享该进程的所有资源。"
          },
          {
            "text": "处理机分给线程，即真正在处理机上运行的是线程。"
          },
          {
            "text": "线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。"
          }
        ]
      },
      {
        "label": "参考",
        "contents": [
          {
            "text": "一文读懂什么是进程、线程、协程",
            "link": "http://www.360doc.com/content/20/0417/14/32196507_906628857.shtml"
          },
          {
            "text": "一文搞懂进程、线程、协程及JS协程的发展",
            "link": "https://juejin.cn/post/7005465381791875109"
          }
        ]
      }
    ]
  },
  {
    "title": "从输入URL到页面加载的全过程",
    "description": "",
    "key": "BrowserFlowPath",
    "imgUrl": "/browser/browser_flow_path.jpg",
    "contents": [
      {
        "text": "在浏览器中输入URL"
      },
      {
        "label": "查找缓存",
        "text": "浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。"
      },
      {
        "label": "DNS域名解析",
        "text": "浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。"
      },
      {
        "label": "建立TCP连接",
        "text": "解析出IP地址后，利用IP地址和默认80端口，通过三次握手和服务器建立TCP连接。"
      },
      {
        "label": "发起HTTP请求",
        "text": "浏览器发起读取文件的HTTP请求，，该请求报文作为TCP三次握手的第三次数据发送给服务器。"
      },
      {
        "label": "服务器响应请求并返回结果",
        "text": "服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器。"
      },
      {
        "label": "关闭TCP连接",
        "text": "通过四次挥手释放TCP连接。"
      },
      {
        "label": "浏览器渲染",
        "text": "客户端（浏览器）解析HTML内容并渲染出来。"
      },
      {
        "label": "JS引擎解析过程",
        "text": "调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）。"
      }
    ]
  },
  {
    "title": "浏览器重绘与重排",
    "description": "",
    "key": "ReflowAndRepaint",
    "contents": [
      {
        "label": "重绘与重排的区别",
        "contents": [
          {
            "label": "重排/回流（Reflow）：",
            "text": "当DOM的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。"
          },
          {
            "label": "重绘(Repaint)：",
            "text": "当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变。"
          },
          {
            "text": "改变元素的外观，不会引起网页重新生成布局，但当浏览器完成重排之后，会重新绘制受到此次重排影响的部分。"
          },
          {
            "text": "重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘。"
          },
          { "text": "『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。" }
        ]
      },
      {
        "label": "如何触发重排和重绘",
        "text": "任何改变用来构建渲染树的信息都会导致一次重排或重绘：",
        "contents": [
          {
            "text": "1、添加、删除、更新DOM节点。"
          },
          {
            "text": "2、通过display: none隐藏一个DOM节点-触发重排和重绘。"
          },
          {
            "text": "3、通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化。"
          },
          {
            "text": "4、移动或者给页面中的DOM节点添加动画。"
          },
          {
            "text": "5、添加一个样式表，调整样式属性。"
          },
          {
            "text": "6、用户行为，例如调整窗口大小，改变字号，或者滚动。"
          }
        ]
      },
      {
        "label": "如何避免重绘或者重排",
        "contents": [
          {
            "text": "1、集中改变样式，不要一条一条地修改 DOM 的样式。"
          },
          {
            "text": "2、不要把 DOM 结点的属性值放在循环里当成循环里的变量。"
          },
          {
            "text": "3、为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。"
          },
          {
            "text": "4、不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。"
          },
          {
            "text": "5、尽量只修改position：absolute或fixed元素，对其他元素影响不大。"
          },
          {
            "text": "6、动画开始GPU加速，translate使用3D变化。"
          },
          {
            "text": "7、提升为合成层：",
            "contents": [
              {
                "text": "将元素提升为合成层有以下优点："
              },
              {
                "text": "1、合成层的位图，会交由 GPU 合成，比 CPU 处理要快"
              },
              {
                "text": "2、当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层"
              },
              {
                "text": "3、对于 transform 和 opacity 效果，不会触发 layout 和 paint"
              }
            ]
          },
          {
            "text": "提升合成层的最好方式是使用 CSS 的 will-change 属性"
          }
        ]
      }
    ]
  }
]
